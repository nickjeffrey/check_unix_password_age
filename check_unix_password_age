#!/usr/bin/perl -w

 
# CHANGE LOG
# ----------
#  2020/02/15	njeffrey	Script created
#  2020/02/16	njeffrey	Add support for popular Linux flavours (CentOS, Ubuntu, Raspbian)
#  2020/02/17	njeffrey	Add support for FreeBSD, OpenBSD, NetBSD
#  2020/02/18	njeffrey	Add support for AIX
#  2020/02/18	njeffrey	Add --maxage=##  --minage=##  parameters
#  2020/07/09	njeffrey	Enhance FreeBSD section to alert if password will expire within 3 days
#  2022/11/28	njeffrey	Change --maxage and --minage parameters from string to integer


# FUTURE ENHANCEMENTS
# -------------------
#  1) Allow @list_of_users to be specified as a parameter instead of hard-coded in script
#  2) Allow for all user accounts to be checked instead of just a specified list of users
#  3) Add support for other UNIX flavours (HP-UX, SunOS, Darwin)


# NOTES
# -----
#  This script is intended to be the all-singing all-dancing nagios check for password age on UNIX-like systems.
#
# This script exists to warn you about expired passwords, based on your existing password policies.
# For example, if your passwords are configured to expire every 90 days, this script will start alerting when passwords are 91+ days old.
#
# This script does not make value judgements about your password policy.  If your max password age is set to 9999 days, this script is cool with your decision.
# If your passwords are set to never expire, this script will never give you any warnings, unless you use the --maxage=## parameter.
#
# If you are not certain what the password rules are on each individual machine, but you have an overall corporate policy similar
# to something like "passwords must expire every 90 days", use this syntax:
#    check_unix_password_age --maxage=90
#
#


# SUPPORTED OPERATING SYSTEMS
# ---------------------------
#  Tested on AIX 6.1 and 7.1, IBM VIOS (based on AIX 6.1 but config file is at /home/padmin/config/ntp.conf)
#  Tested on CentOS 7, Ubuntu 20.04, Raspbian
#  Tested on FreeBSD 12.1, OpenBSD 6.6, NetBSD 9.0
#  Not yet tested on MacOS, SunOS, HP-UX, MacOS/Darwin (patches welcome)



# USAGE 
# -----
#  This script is executed remotely on a monitored system by the NRPE or check_by_ssh
#  methods available in nagios.
#
#  If you are using the check_by_ssh method, you will need a section in the services.cfg
#  file on the nagios server that looks similar to the following.
#  This assumes that you already have ssh key pairs configured.
#   # Define service for checking password age
#   define service{
#           use                             generic-24x7-service
#           hostgroup_name                  all_linux,all_freebsd,all_aix
#           service_description             password age
#           check_command                   check_by_ssh!"/usr/local/nagios/libexec/check_unix_password_age"
#           }
#
#  If you are using the check_nrpe method, you will need a section in the services.cfg
#  file on the nagios server that looks similar to the following.
#  This assumes that you already have ssh key pairs configured.
#   # Define service for checking time synchronization
#   define service{
#           use                             generic-24x7-service
#           host_name                       unix11,unix12,unix13
#           service_description             password age
#           check_command                   check_nrpe!check_unix_password_age 
#           }
#
#  If using NRPE, you will also need a section defining the NRPE command in the /usr/local/nagios/nrpe.cfg file that looks like this:
#   command[check_unix_password_age]=/usr/local/nagios/libexec/check_unix_password_age
#
#
# Schedule this script to run every 12 hours from the root crontab, which will update a file at /tmp/nagios.check_unix_password_age.tmp
# When this script runs as the low-privileged nagios user, the script will read the contents of /tmp/nagios.check_unix_password_age.tmp 
# Create cron entries in the root user crontab similar to the following:  (one for each vmware host)
#   1 1,13 * * * /usr/local/nagios/libexec/check_unix_password_age  1>/dev/null 2>/dev/null





# ASSUMPTIONS
# -----------
#  It is assumed that perl is installed on the machine running this script.
#     For RHEL / CentOS     yum install perl
#     For Debian / Ubuntu   apt install perl
#     For FreeBSD           pkg install perl5
#     For OpenBSD           (perl should already be in base install)
#     For NetBSD            pkg_add install perl5
#     For AIX               (perl should already be in base install)
#
#  It is assumed that passwords do have an expiry date (ie 60 days, 90 days, etc)
#
#  It is assumed that this script is being run as a low-privileged user (typically nagios)







# TROUBLESHOOTING
# ---------------
#   The first line of this script is #!/usr/bin/perl, which is fine for most UNIX-like operating systems.
#   However, FreeBSD puts the perl binary at /usr/local/bin/perl, so please create a symlink on FreeBSD:
#      ln -s /usr/local/bin/perl /usr/bin/perl
#
#   This script requires root privileges to run the following commands:
#       lsuser ; pwdadm         (AIX)
#       cat /etc/shadow         (Linux)
#       cat /etc/master.passwd  (FreeBSD,OpenBSD,NetBSD)
#
#   Rather than give the nagios user and additional privileges, this script will run from the root crontab every 12 hours,
#   generating a /tmp/nagios.check_unix_password.age.tmp file.  This file will be read by the low-privileged nagios user
#   when the check is run from nagios.
#   Ensure the root crontab has an entry similar to the following:
#   1 1,13 * * * /usr/local/nagios/libexec/check_unix_password_age >/dev/null 2>&1 #nagios helper script 




use strict;						#enforce good coding practices
use Getopt::Long;                       		#allow --long-switches to be used as parameters

#declare variables
my ($verbose,$os,$cmd,$key);
my ($uname,$passwordfile,$lsuser,$pwdadm);
my ($password_maxage_days,$password_minage_days,$password_age_days,$password_lastupdate,$password_days_left);
my ($seconds_since_epoch,$days_since_epoch,$check_maxage,$check_minage);
my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);
my ($common_output_data,$perf_data,$output_filename,$output_file_age,$output_message);
my (@list_of_users,$current_user,%users);
my ($OK,$WARN,$CRITICAL,$UNKNOWN,$CHECK_NAME);
my ($opt_h,$opt_v,$opt_m,$opt_M,$opt_u);
$verbose            = "no";				#yes/no flag to increase verbosity during debugging
$common_output_data = "";                               #nagios output
$perf_data          = "";                               #nagios performance data included in output
$CHECK_NAME         = "password age";
@list_of_users      = ("root","padmin","oracle","testuser");		#all the usernames to check.  Should contain at least the root user.  


#
# Nagios return codes
#
$OK=		0;
$WARN=		1;
$CRITICAL=	2;
$UNKNOWN=	3;




sub get_options {
   #
   # this gets the command line parameters provided by the users
   #
   print "Running get_options subroutine \n" if ($verbose eq "yes");
   Getopt::Long::Configure('bundling');
   GetOptions(
      "h"   => \$opt_h, "help"        => \$opt_h,
      "v"   => \$opt_v, "verbose"     => \$opt_v,
      "m=i" => \$opt_m, "minage=i"    => \$opt_m,
      "M=i" => \$opt_M, "maxage=i"    => \$opt_M,
      "u=s" => \$opt_u, "user=s"      => \$opt_u,
   );
   #
   # If the user supplied the --verbose switch, increase output verbosity
   #
   if( defined( $opt_v ) ) {
      $verbose = "yes";
   } else {
      $verbose = "no";
   }
   #
   # If the user supplied the -h or --help switch, give them some help.
   #
   if( defined( $opt_h ) ) {
      print "Use this syntax \n";
      print "   $0 \n";
      print "   $0 --verbose     (increase output for debugging) \n";
      print "   $0 --maxage=90   (warn if password maximum age is > 90 days) \n";
      print "   $0 --minage=7    (warn if password minimum age is <  7 days) \n";
      print "   $0 --user=user1,user2,user3  (optional, will default to root,padmin,oracle)  \n";
      exit $CRITICAL;				#exit script
   }
   #
   # check to see if the user supplied --minage=## 
   #
   if( defined( $opt_m ) ) {
      $check_minage = $opt_m;
      #
      # confirm provided value is an integer of 0 or larger
      unless ( $check_minage =~ /^[0-9]+$/ ) {
         print "$CHECK_NAME UNKNOWN --minage=$check_minage must be an integer.  Please try again. \n";
         exit $UNKNOWN;				#exit script
      }						#end of unless block
   }
   #
   # check to see if the user supplied --maxage=## 
   #
   if( defined( $opt_M ) ) {
      $check_maxage = $opt_M;
      #
      # confirm provided value is an integer of 0 or larger
      unless ( $check_maxage =~ /^[0-9]+$/ ) {
         print "$CHECK_NAME UNKNOWN --maxage=$check_maxage must be an integer.  Please try again. \n";
         exit $UNKNOWN;				#exit script
      }						#end of unless block
   }
   #
   # check to see if the user supplied -u user1,user2,user3 or --user=user1,user2,user3
   #
   if( defined( $opt_u ) ) {
      @list_of_users = split (',',$opt_u);
      print "   will check these users: @list_of_users \n" if ($verbose eq "yes");
   }
}             				    	#end of subroutine





sub sanity_checks {
   #
   print "Running sanity_checks subroutine \n" if ($verbose eq "yes");
   #
   # confirm uname binary exists and is executable
   # figure out where the uname command is on this system (varies across UNIX flavors)
   $uname = "/bin/uname"      if ( -e "/bin/uname");	
   $uname = "/sbin/uname"     if ( -e "/sbin/uname");	
   $uname = "/usr/bin/uname"  if ( -e "/usr/bin/uname");	
   $uname = "/usr/sbin/uname" if ( -e "/usr/sbin/uname");	
   if ( ! -e $uname ) {
      print "ERROR: Cannot find $uname binary \n";
      exit $CRITICAL;
   }
   if ( ! -x $uname ) {
      print "ERROR: $uname is not executable by the current user \n";
      exit $CRITICAL;
   }
   print "   found uname binary at $uname \n" if ($verbose eq "yes");
   #
   # If --minage=# and --maxage=# were both provided as parameters, confirm minage<maxage
   if ( (defined($check_minage)) && (defined($check_maxage)) ) {
      unless ( $check_minage < $check_maxage ) {
         print "$CHECK_NAME UNKNOWN - impossible values for --minage=$check_minage --maxage=$check_maxage.  Max must be greater than Min. \n";
         exit $UNKNOWN;
      } 					#end of unless block
   } 						#end of if block
}						#end of subroutine




sub check_for_output_file {
   #
   # a cron job may have already created the output file that we need
   #
   print "running check_for_output_file subroutine \n" if ($verbose eq "yes");
   #
   $output_filename = "/tmp/nagios.check_unix_password_age.tmp";
   #
   # delete the output file if it is more than 12 hours (43200 seconds) old
   if ( -e $output_filename ) {                		                	#see if a cron job has already provided the info we need
      ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($output_filename); #get last modification time in seconds since the epoch
      $output_file_age = time - $mtime;                                 	#figure out how many seconds old the file is
      print "   output file $output_filename is $output_file_age seconds old \n" if ($verbose eq "yes");
      if( $output_file_age >= 43200 ) {                                 	#see if the file is more than 43200 seconds old
         print "   deleting old copy of $output_filename \n" if ($verbose eq "yes");
         unlink "$output_filename";                                     	#delete the file if it is too old
      }										#end of if block
   }                                                                    	#end of if block
   #
   if ( -e "$output_filename" ) {        	                       		#see if a cron job has already provided the info we need
      open (OUT,"$output_filename") or die "Cannot open $output_filename for reading $! \n";
      while (<OUT>) {                                                   	#read a line from the text file
         $output_message = $_  if ( $_ =~ /[a-zA-Z]/);                  	#get the content of the output file into a variable
         print "   output message is $output_message \n" if ($verbose eq "yes");
      }                                                                 	#end of while loop
      close OUT;                                                        	#close filehandle
      print $output_message;                                            	#print the content of the output file
      exit $CRITICAL if ( $output_message =~ /CRITICAL/ );              	#exit script with appropriate return code
      exit $WARN     if ( $output_message =~ /WARN/ );                  	#exit script with appropriate return code
      exit $UNKNOWN  if ( $output_message =~ /UNKNOWN/ );               	#exit script with appropriate return code
      exit $OK       if ( $output_message =~ /OK/ );                    	#exit script with appropriate return code
   }                                                                    	#end of if block
}                                                                       	#end of subroutine




sub print_to_outputfile {
   #
   print "running print_to_outputfile \n" if ($verbose eq "yes");
   #
   # This subroutine is called whenever an output message is printed, to confirm that the $output_file exists
   #
   # confirm the output message exists
   $output_message = "$CHECK_NAME UNKNOWN - could not parse response from remote host \n" unless ($output_message);
   #
   # confirm the $output_filename variable is defined
   unless ($output_filename) {
      print "$CHECK_NAME UNKNOWN - the \$output_filename variable is not defined.  This might be a script bug. \n";
      exit $UNKNOWN;                                                            #only get this far if OK/WARN/CRITICAL/UNKNOWN was not found in the output file
   }                                                                            #end of unless block
   #
   if ( ! -e "$output_filename" ) {                                             #only run this section if $output_filename does not already exist
      print "   $output_filename not found - writing output message to $output_filename \n" if ($verbose eq "yes");
      open (OUT,">$output_filename") or die "Cannot open $output_filename for writing: $! \n";
      print OUT "$output_message";
      close OUT;                                                                #close filehandle
      chmod 0644, "$output_filename";                                           #set the file permission to -rw-r--r-- to ensure nagios user can read file
   }                                                                            #end of if block
}                                                                               #end of subroutine



sub determine_os {
   #
   print "Running determine_os subroutine \n" if ($verbose eq "yes");
   #
   $cmd = "$uname";
   print "   running command: $cmd \n" if ($verbose eq "yes");
   open(IN,"$cmd |");                                                   	#open filehandle using command output
   while (<IN>) {                                                       	#read a line from the command output
      if    (/AIX/)     { $os = "AIX"     }
      elsif (/Linux/)   { $os = "Linux"   }
      elsif (/FreeBSD/) { $os = "FreeBSD" }
      elsif (/NetBSD/)  { $os = "NetBSD"  }
      elsif (/OpenBSD/) { $os = "OpenBSD" }
      elsif (/Darwin/)  { $os = "Darwin"  }
      elsif (/HP-UX/)   { $os = "HP-UX"   }
      elsif (/SunOS/)   { $os = "SunOS"   }
      else {
         print "ERROR: Cannot determine operating system \n";
         exit $CRITICAL;
      } 									#end of if/elsif/else block
   } 										#end of while loop
   close IN;									#close filehandle
   print "   operating system is $os \n" if ($verbose eq "yes");
   $common_output_data = "$common_output_data OS=$os,";				#add OS to the info that will be included in the script output
}										#end of subroutine




sub AIX {
   #
   return unless ($os eq "AIX");
   print "Running AIX subroutine \n" if ($verbose eq "yes");
   #
   #
   # confirm required files exist
   #
   $lsuser = "/usr/sbin/lsuser";
   $pwdadm = "/usr/bin/pwdadm";
   $passwordfile = "/etc/security/passwd";					#On Linux, this would be the /etc/shadow file containing the password hashes and lastupdate field.
   if ( ! -e $lsuser ) {
      print "ERROR: Cannot find $lsuser binary \n";
      exit $CRITICAL;
   }
   if ( ! -x $lsuser ) {
      print "ERROR: $lsuser is not executable by the current user \n";
      exit $CRITICAL;
   }
   if ( ! -e $pwdadm ) {
      print "ERROR: Cannot find $pwdadm binary \n";
      exit $CRITICAL;
   }
   if ( ! -x $pwdadm ) {
      print "ERROR: $pwdadm is not executable by the current user \n";
      exit $CRITICAL;
   }
   if ( ! -r $passwordfile ) {
      print "ERROR: $passwordfile is not readable by the current user \n";
      exit $CRITICAL;
   }
   if ( ! -e $passwordfile ) {
      print "ERROR: Cannot find $passwordfile \n";
      exit $CRITICAL;
   }
   #   
   # Loop through for each userid
   #   
   foreach $current_user (@list_of_users) {					#loop through for all defined user accounts
      #
      # initialize variables to ensure values are calculated fresh for each user
      $password_lastupdate  = ""; undef $password_lastupdate;
      $password_age_days    = ""; undef $password_age_days;
      $password_minage_days = ""; undef $password_minage_days;
      $password_maxage_days = ""; undef $password_maxage_days;
      $password_days_left   = ""; undef $password_days_left;
      #
      #   
      # Get the maximum password age (AIX tracks this in weeks)
      #   
      $cmd = "$lsuser -a maxage $current_user";
      print "   running command: $cmd \n" if ($verbose eq "yes");
      open(IN,"$cmd 2>&1|");                                                   	#open filehandle from command output
      while (<IN>) {                                                       	#read a line from the command output
         if ( /maxage=([0-9]+)/ ) {    						#find maximum password age in weeks
            $password_maxage_days = $1 * 7;					#multiply by 7 to convert weeks to days		
         }									#end of if block
      }										#end of while loop
      close IN;									#close filehandle
      #   
      # Get the minimum password age (AIX tracks this in weeks)
      #   
      $cmd = "$lsuser -a minage $current_user";
      print "   running command: $cmd \n" if ($verbose eq "yes");
      open(IN,"$cmd 2>&1|");                                                   	#open filehandle from command output
      while (<IN>) {                                                       	#read a line from the command output
         if ( /minage=([0-9]+)/ ) {    						#find maximum password age in weeks
            $password_minage_days = $1 * 7;					#multiply by 7 to convert weeks to days		
         }									#end of if block
      }										#end of while loop
      close IN;									#close filehandle
      #
      # Figure out the last time the password was changed
      #
      $cmd = "$pwdadm -q $current_user";
      print "   running command: $cmd \n" if ($verbose eq "yes");
      open(IN,"$cmd 2>&1 |");                                                   #open filehandle from command output
      while (<IN>) {                                           	            	#read a line from the command output
         if ( /lastupdate = ([0-9]+)/ ) {    					#find password last update in seconds since epoch
            $password_lastupdate = $1;						#
            $seconds_since_epoch = time;					#figure out the number of seconds since epoch
            $password_age_days   = ($seconds_since_epoch-$password_lastupdate)/60/60/24; #calculate number of days since last password change
            $password_age_days   = sprintf("%.0f",$password_age_days);   	#truncate to 0 decimal places.  Nearest whole day is close enough.
            $password_days_left  = $password_maxage_days-$password_age_days;	#calculate remaining days until password expires
            print "   user:$current_user seconds_since_epoch:$seconds_since_epoch  password_lastupdate:$password_lastupdate days_left:$password_days_left \n" if ($verbose eq "yes");
         }									#end of if block
      }										#end of while loop
      close IN;									#close filehandle
      #
      # stick all the above details into a hash so we can keep track of multiple users
      if ( defined($password_age_days) ) {
         print "   adding user $current_user to hash \n" if ($verbose eq "yes");
         $users{$current_user}{name}                 = $current_user;
         $users{$current_user}{password_maxage_days} = $password_maxage_days;
         $users{$current_user}{password_minage_days} = $password_minage_days;
         $users{$current_user}{password_age_days}    = $password_age_days;
         $users{$current_user}{password_days_left}   = $password_days_left;
         #
         $common_output_data = "$common_output_data user:$current_user age:$password_age_days minage:$password_minage_days maxage:$password_maxage_days days_left:$password_days_left,";
         print "      $common_output_data \n" if ($verbose eq "yes");
      } 									#end of if block
   }										#end of foreach loop
}										#end of subroutine





sub Linux {
   #
   return unless ($os eq "Linux");
   print "Running Linux subroutine \n" if ($verbose eq "yes");
   #
   # On Linux systems, the /etc/shadow file contains the following fields:
   # username:EncryptedPassword:DaysFromEpochSinceLastPasswordChange:MinimumDaysBetweenPasswordChange:MaxDaysBetweenPasswordChange:Warning::
   # For example:
   #chage -l root
   #Last password change                                    : Feb 15, 2020
   #Password expires                                        : never
   #Password inactive                                       : never
   #Account expires                                         : never
   #Minimum number of days between password change          : 0
   #Maximum number of days between password change          : 99999
   #Number of days of warning before password expires       : 7
   #
   #
   # confirm required files exist
   #
   $passwordfile = "/etc/shadow";
   if ( ! -e $passwordfile ) {
      print "ERROR: Cannot find $passwordfile file \n";
      exit $CRITICAL;
   }
   if ( ! -r $passwordfile ) {
      print "ERROR: $passwordfile is not readable by the current user \n";
      exit $CRITICAL;
   }
   #
   #
   # Figure out the last time the password was changed
   #
   foreach my $current_user (@list_of_users) {					#loop through for all defined user accounts
      #
      # initialize variables to ensure values are calculated fresh for each user
      $password_lastupdate  = ""; undef $password_lastupdate;
      $password_age_days    = ""; undef $password_age_days;
      $password_minage_days = ""; undef $password_minage_days;
      $password_maxage_days = ""; undef $password_maxage_days;
      $password_days_left   = ""; undef $password_days_left;
      #
      open(IN,"$passwordfile");                                                	#open filehandle for reading
      while (<IN>) {                                                       	#read a line from the command output
         if ( /^$current_user:.*:([0-9]+):([0-9]+):([0-9]+):([0-9]+)/ ) {  	#find line in /etc/shadow with password age details
            $password_lastupdate  = $1;						#
            $seconds_since_epoch  = time;					#figure out the number of seconds since epoch
            $days_since_epoch     = $seconds_since_epoch/60/60/24;		#figure out the number of days    since epoch
            $password_age_days    = ($days_since_epoch-$password_lastupdate); 	#calculate number of days since last password change
            $password_age_days    = sprintf("%.0f",$password_age_days);   	#truncate to 0 decimal places.  Nearest whole day is close enough.
            $password_minage_days = $2;						#fourth field, minimum days between password changes
            $password_maxage_days = $3;						#fifth  field, maximum days between password changes
            $password_days_left   = $password_maxage_days-$password_age_days;	#calculate remaining days until password expires
            #
            # stick all the above details into a hash so we can keep track of multiple users
            $users{$current_user}{name} = $current_user;
            $users{$current_user}{password_age_days} = $password_age_days;
            $users{$current_user}{password_minage_days} = $password_minage_days;
            $users{$current_user}{password_maxage_days} = $password_maxage_days;
            $users{$current_user}{password_days_left} = $password_days_left;
            #
            $common_output_data = "$common_output_data user:$current_user age:$password_age_days minage:$password_minage_days maxage:$password_maxage_days days_left:$password_days_left,";
            print "$common_output_data \n" if ($verbose eq "yes");
         }									#end of if block
      }										#end of while loop
      close IN;									#close filehandle
   } 										#end of for loop
}										#end of subroutine




sub BSD {
   #
   return unless ( ($os eq "FreeBSD") || ($os eq "OpenBSD") || ($os eq "NetBSD") );
   print "Running BSD subroutine \n" if ($verbose eq "yes");
   #
   # 
   # On FreeBSD|OpenBSD|NetBSD, the /etc/master.passwd file is similar to /etc/shadow on Linux.
   # The format of /etc/master.passwd is:
   # username:EncryptedPassword:uid:gid:class:change:expire:gecos:home_dir:shell
   #
   # The change field is the number of seconds from the epoch, UTC, until the password for the account must be changed. 
   # This field may be left empty to turn off the password aging feature.
   # A value of zero is equivalent to leaving the field empty.
   #
   # The expire field is the number of seconds from the epoch, UTC, until the account expires.  
   # This field may be left empty to turn off the account aging feature.
   # A value of zero is equivalent to leaving the field empty.
   #
   # By default, FreeBSD|OpenBSD|NetBSD does not have password expiration enabled, so the "change" field will be 0
   #
   #
   # FreeBSD method to enforce password expiry (tested with FreeBSD 12.1)
   # --------------------------------------------------------------------
   # To enforce a password expiration every 90 days, use this command:  pw user mod USERNAME -p +90d  
   # By running the above command, the sixth field of /etc/master.passwd will be updated with the password expiry date, in seconds since epoch.
   # For example:
   #root:EncryptedPassword:0:0::0:0:Charlie:/root:/bin/csh                              (sixth field is 0, so never expires)
   #janedoe:EncryptedPassword:1001:1001::1585344476:0:Jane Doe:/home/janedoe:/bin/sh    (sixth field is 1585344476, so expires on that many seconds past epoch)
   #
   #
   # OpenBSD method to enforce password expiry  (tested with OpenBSD 6.6)
   # --------------------------------------------------------------------
   # Unlike FreeBSD, OpenBSD does not have a "pw user mod USERNAME -p +90d" command, 
   # so if you want to enforce password expiration, you will need to manually update 
   # the sixth field of /etc/master.passwd with the date the password expires, shown in seconds since the epoch.
   # For example, let's get the current seconds since the epoch:  
   #   date +%s
   #   1582761761
   # Now figure out how many seconds are in 90 days
   #   echo 60*60*24*90|bc
   #   7776000
   # Now add those numbers together to figure out the number of seconds from epoch to 90 days from now
   #   echo 1582761761+7776000|bc
   #   1590537761
   # Now you know the value to put in the sixth field of /etc/master.passwd
   # Look at the current value in /etc/master.passwd and you will notice it is currently 0, which means no password expiry
   #   grep testuser /etc/master.passwd
   #   testuser:EncryptedPassword:1000:1000::0:0:test user:/home/testuser:/bin/ksh
   # Update the sixth field in /etc/master.passwd with  "vipw testuser", which will make the file look similar to:
   #   testuser:EncryptedPassword:1000:1000::1590537761:0:test user:/home/testuser:/bin/ksh
   # 
   # NetBSD method to enforce password expiry  (tested with NetBSD 9.0)
   # --------------------------------------------------------------------
   # (same as OpenBSD)
   #
   #
   # confirm required files exist
   #
   $passwordfile = "/etc/master.passwd";
   if ( ! -e $passwordfile ) {
      print "ERROR: Cannot find $passwordfile file \n";
      exit $CRITICAL;
   }
   if ( ! -r $passwordfile ) {
      print "ERROR: $passwordfile is not readable by the current user \n";
      exit $CRITICAL;
   }
   #
   #
   # *BSD does not track the last password change date, but the sixth field in /etc/master.passwd
   # shows when the password will expire, in seconds since the epoch.
   #
   foreach my $current_user (@list_of_users) {					#loop through for all defined user accounts
      #
      # initialize variables to ensure values are calculated fresh for each user
      $password_lastupdate  = ""; undef $password_lastupdate;
      $password_age_days    = ""; undef $password_age_days;
      $password_minage_days = ""; undef $password_minage_days;
      $password_maxage_days = ""; undef $password_maxage_days;
      $password_days_left   = ""; undef $password_days_left;
      #
      $password_age_days    = 0; 						#*SD does not track this value.  Put in dummy value of zero.
      $password_minage_days = 0;						#*BSD does not track this value.  Put in dummy value of zero.
      $password_maxage_days = 0;						#*BSD does not track this value.  Put in dummy value of zero.
      $password_lastupdate  = 0;						#*BSD does not track this value.  Put in dummy value of zero.
      #
      open(IN,"$passwordfile");                                                	#open filehandle for reading
      while (<IN>) {                                                       	#read a line from the command output
         if ( /^$current_user:.*:[0-9]+:[0-9]+:.*:([0-9]+):[0-9]+/ ) {  	#find line in /etc/master.passwd with password age details
            my $password_expiry = $1;
            $seconds_since_epoch  = time;					#figure out the number of seconds since epoch
            $password_days_left   = ($password_expiry-$seconds_since_epoch)/60/60/24;         #figure out remaining days before password expires
            $password_days_left   = sprintf("%.0f",$password_days_left);        #truncate to 0 decimal places.  Nearest whole day is close enough.
            $password_days_left   = 99999 if ( $password_expiry ==  0);       			#set to huge bogus value if password never expires.  Still needs to be numeric to do math against.
            #
            # stick all the above details into a hash so we can keep track of multiple users
            $users{$current_user}{name}                 = $current_user;
            $users{$current_user}{password_age_days}    = $password_age_days;
            $users{$current_user}{password_maxage_days} = $password_maxage_days;
            $users{$current_user}{password_days_left}   = $password_days_left;
            #
            $common_output_data = "$common_output_data user:$current_user age:$password_age_days minage:$password_minage_days maxage:$password_maxage_days days_left:$password_days_left,";
            print "$common_output_data \n" if ($verbose eq "yes");
            print "    seconds_since_epoch:$seconds_since_epoch  password_expiry:$password_expiry \n" if ($verbose eq "yes");
         }									#end of if block
      }										#end of while loop
      close IN;									#close filehandle
   } 										#end of for loop
}										#end of subroutine




sub Darwin {
   #
   return unless ($os eq "Darwin");
   print "Running Darwin subroutine \n" if ($verbose eq "yes");
   #
   print "$CHECK_NAME UNKNOWN - support for the $os operating system has not been added to this script \n";
   exit $UNKNOWN;
}						#end of subroutine



sub HPUX {
   #
   return unless ($os eq "HP-UX");
   print "Running HPUX subroutine \n" if ($verbose eq "yes");
   #
   print "$CHECK_NAME UNKNOWN - support for the $os operating system has not been added to this script \n";
   exit $UNKNOWN;
}						#end of subroutine



sub SunOS {
   #
   return unless ($os eq "SunOS");
   print "Running SunOS subroutine \n" if ($verbose eq "yes");
   #
   print "$CHECK_NAME UNKNOWN - support for the $os operating system has not been added to this script \n";
   exit $UNKNOWN;
}						#end of subroutine




sub print_output {
   #
   print "Running print_output subroutine \n" if ($verbose eq "yes");
   #
   #
   # Send alert if the password is expired (days since last change is greater than maximum allowed age)
   # This section works on AIX, Linux  because those operating systems track the last password change date, and the password maximum age.
   # This section will not work on FreeBSD, which only tracks the password expiry date.
   foreach $key (keys %users) {
      print "   user:$users{$key}{name} age:$users{$key}{password_age_days} maxage:$users{$key}{password_maxage_days} days_left:$users{$key}{password_days_left} \n" if ($verbose eq "yes");
      next unless ($users{$key}{name});
      next unless ($users{$key}{password_age_days});
      next unless ($users{$key}{password_maxage_days});
      next unless ($users{$key}{password_days_left});
      if ( $users{$key}{password_age_days} > $users{$key}{password_maxage_days} ) {
         $output_message = "$CHECK_NAME WARN - expired password for $users{$key}{name} user.  Age:$users{$key}{password_age_days}, MaxAge:$users{$key}{password_maxage_days}, Days_Left:$users{$key}{password_days_left}.  $common_output_data | $perf_data \n";
         print "$output_message";					#print output to screen
         print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
         exit $WARN;
      } 								#end of if block
   } 									#end of foreach block
   #
   #
   # Send alert if the password is expired (expiry date has been reached)
   # This section will work on FreeBSD, which only tracks the password expiry date.
   foreach $key (keys %users) {
      print "   user:$users{$key}{name} age:$users{$key}{password_age_days} maxage:$users{$key}{password_maxage_days} days_left:$users{$key}{password_days_left} \n" if ($verbose eq "yes");
      next unless ($users{$key}{name});
      next unless ($users{$key}{password_days_left});
      if ( ($users{$key}{password_days_left} > 0) && ($users{$key}{password_days_left} < 3)  ) {
         $output_message = "$CHECK_NAME WARN - password for $users{$key}{name} will expire in $users{$key}{password_days_left} days.  $common_output_data | $perf_data \n";
         print "$output_message";					#print output to screen
         print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
         exit $WARN;
      } 								#end of if block
      if ( $users{$key}{password_days_left} < 1 ) {
         $output_message = "$CHECK_NAME WARN - expired password for $users{$key}{name} user.  Days_Left:$users{$key}{password_days_left}.  $common_output_data | $perf_data \n";
         print "$output_message";					#print output to screen
         print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
         exit $WARN;
      } 								#end of if block
   } 									#end of foreach block
   #
   #
   ## If the --maxage=## parameter was provided, confirm that none of the passwords have days_left larger than  --maxage=##
   # If the --maxage=## parameter was provided, confirm that none of the passwords have password_age_days larger than  --maxage=##
   foreach $key (keys %users) {
      print "   user:$users{$key}{name} age:$users{$key}{password_age_days} maxage:$users{$key}{password_maxage_days} days_left:$users{$key}{password_days_left} \n" if ($verbose eq "yes");
      next unless ($users{$key}{name});
      next unless ($users{$key}{password_days_left});
      next unless ($check_maxage);
      #if ( $users{$key}{password_days_left} > $check_maxage ) {
      if ( $users{$key}{password_age_days} > $check_maxage ) {
         $output_message = "$CHECK_NAME WARN - Passwords are not allowed to be more than $check_maxage days old, but $users{$key}{name} user password is $users{$key}{password_age_days} days old.  Please check the password expiry rules.  $common_output_data | $perf_data \n";
         print "$output_message";					#print output to screen
         print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
         exit $WARN;
      } 								#end of if block
   } 									#end of foreach block
   #
   #
   # If the --minage=## parameter was provided, confirm that none of the passwords can be changed more frequently than --minage
   foreach $key (keys %users) {
      print "   user:$users{$key}{name} age:$users{$key}{password_age_days} maxage:$users{$key}{password_maxage_days} days_left:$users{$key}{password_days_left} \n" if ($verbose eq "yes");
      next unless ($users{$key}{name});
      next unless ($users{$key}{password_days_left});
      next unless ($check_minage);
      next if     ($os eq "FreeBSD");					#does not support minimum password change intervals
      next if     ($os eq "OpenBSD");					#does not support minimum password change intervals
      next if     ($os eq "NetBSD");					#does not support minimum password change intervals
      if ( $users{$key}{password_minage_days} < $check_minage ) {
         $output_message = "$CHECK_NAME WARN - Passwords are not allowed to be changed more frequently than every $check_minage days, but $users{$key}{name} user password can change every $users{$key}{password_minage_days} days.  Please check the password expiry rules.  $common_output_data | $perf_data \n";
         print "$output_message";					#print output to screen
         print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
         exit $WARN;							#exit script
      } 								#end of if block
   } 									#end of foreach block
   #
   #
   # should only get here if everything is ok
   $output_message = "$CHECK_NAME OK - no expired passwords found.  $common_output_data | $perf_data \n";
   print "$output_message";						#print output to screen
   print_to_outputfile;           					#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
   exit $OK;								#exit script
}									#end of subroutine




# ---------------- main body of script -------------------------
get_options;
sanity_checks;
check_for_output_file;
determine_os;
AIX;
Linux;
BSD;
Darwin;
HPUX;
SunOS;
print_output;

